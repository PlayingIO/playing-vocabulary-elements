<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../paper-button/paper-button.html">
<link rel="import" href="../../paper-card/paper-card.html">
<link rel="import" href="../../paper-item/paper-item.html">
<link rel="import" href="../../paper-button/paper-button.html">
<link rel="import" href="../../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../paper-dialog/paper-dialog.html">
<link rel="import" href="../../mostly-elements/mostly-app/mostly-page.html">
<link rel="import" href="../../mostly-elements/mostly-common/mostly-resource.html">
<link rel="import" href="../../mostly-elements/mostly-common/mostly-layout.html">
<link rel="import" href="../../mostly-elements/mostly-data-table/iron-data-table.html">
<link rel="import" href="../../mostly-elements/widgets/mostly-select.html">

<!--
`playing-vocabulary-management`
@group Playing UI
@element playing-vocabulary-management
-->
<dom-module id="playing-vocabulary-management">
  <template>
    <style>
      :host {
        display: block;
      }

      mostly-data-table {
        min-height: calc(100vh - 280px);
      }

      .top.actions {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        @apply(--layout-end-justified);
        margin: 1em 0 1em 0;
      }

      mostly-select {
        max-width: 223px;
      }

      ::content paper-dialog {
        min-width: 480px;
      }

      @media (max-width: 1024px) {
        ::content paper-dialog {
          min-width: 0;
          width: 90%;
        }
      }

      ::content paper-dialog ::content .buttons {
        @apply(--layout-horizontal);
        @apply(--layout-justified);
        margin-top: 16px;
        background-color: var(--mostly-dialog-buttons-bar, white);
      }

      ::content label {
        @apply(--nuxeo-label);
      }
    </style>

    <mostly-resource id="directory" path="/directory"></mostly-resource>

    <mostly-page>
      <div class="header layout horizontal">
        <span>[[i18n('vocabularyManagement.heading')]]</span>
      </div>

      <div class="content">
        <paper-card elevation="0" class="block">
          <mostly-select label="[[i18n('vocabularyManagement.vocabulary')]]"
                  placeholder="[[i18n('vocabularyManagement.select')]]"
                  selected="{{selectedVocabulary}}" attr-for-selected="name">
            <template is="dom-repeat" items="[[vocabularies]]" as="vocabulary">
              <paper-item name$="[[vocabulary.name]]">[[vocabulary.name]]</paper-item>
            </template>
          </mostly-select>
        </paper-card>

        <template is="dom-if" if="[[_isVocabularySelected(selectedVocabulary)]]">
          <div class="top actions">
            <paper-button id="addEntry" class="primary" on-tap="_createEntry">
              <span>+ [[i18n('vocabularyManagement.addEntry')]]</span>
            </paper-button>
          </div>
          <mostly-data-table id="table" items="[[entries]]"
            empty-label="[[i18n('vocabularyManagement.noEntry')]]"
            empty-label-when-filtered="[[i18n('vocabularyManagement.noEntryWhenFiltered')]]">
            <template is="dom-repeat" items="[[colDef]]" as="col">
              <mostly-data-table-column name="[[i18n(col.name)]]" key="[[col.key]]">
                <template>
                  <template is="dom-if" if="[[!_entryActions(column.key)]]">
                    [[_value(item, column.key)]]
                  </template>
                  <template is="dom-if" if="[[_entryActions(column.key)]]">
                    <paper-icon-button id="edit-button-[[index]]" icon="nuxeo:edit" on-tap="_editEntry"></paper-icon-button>
                    <paper-tooltip for="edit-button-[[index]]">[[i18n('vocabularyManagement.editEntry')]]</paper-tooltip>
                    <paper-icon-button id="delete-button-[[index]]" name="delete" icon="nuxeo:delete" on-tap="_deleteEntry"></paper-icon-button>
                    <paper-tooltip for="delete-button-[[index]]">[[i18n('vocabularyManagement.deleteEntry')]]</paper-tooltip>
                  </template>
                </template>
              </mostly-data-table-column>
            </template>
          </mostly-data-table>
        </template>
      </div>
    </mostly-page>

    <paper-dialog id="dialog" with-backdrop no-auto-focus>
      <h2>[[i18n('vocabularyManagement.popup.editEntry')]]</h2>
      <form id="form" is="iron-form" action="/">
        <mostly-layout id="layout"
                href="[[_layoutHref(_selectedSchema)]]"
                model="[[_layoutModel(_selectedEntry)]]"
                error="[[i18n('documentVocabularyManagement.layoutNotFound', _selectedSchema)]]">
        </mostly-layout>
      </form>
      <div class="buttons">
        <paper-button name="cancel" noink dialog-dismiss>[[i18n('command.cancel')]]</paper-button>
        <paper-button name="save" noink class="primary" on-tap="_save">[[i18n('command.save')]]</paper-button>
      </div>
    </paper-dialog>

  </template>

  <script>
    Polymer({
      is: 'playing-vocabulary-management',
      behaviors: [Mostly.I18nBehavior],
      properties: {
        vocabularies: Array,
        selectedVocabulary: String,
        entries: {
          type: Array,
          value: []
        },
        colDef: {
          type: Object,
          notify: true
        },
        visible: {
          type: Boolean,
          observer: '_visibleChanged'
        },
        _selectedEntry: {
          type: Object
        },
        _selectedSchema: {
          type: String,
          computed: '_schemaFor(_selectedEntry)'
        }
      },

      observers: [
        '_refresh(selectedVocabulary)'
      ],

      _visibleChanged: function() {
        if (this.visible && !this.vocabularies) {
          this.$.directory.get().then(function(response) {
            this.vocabularies = response.entries;
          }.bind(this));
        }
      },

      /**
       * Returns the href for the current layout element
       */
      _layoutHref: function(schema) {
        return this.resolveUrl(schema + '/playing-' + schema + '-edit-layout.html');
      },

      _layoutModel: function() {
        return {
          entry: this._selectedEntry,
          parentDirectory: this._getParentDirectoryFor(this._selectedEntry),
          entries: this.entries,
          "new": this._new
        };
      },

      _schemaFor: function(entry) {
        if (!entry) {
          return;
        }
        var schema = '';
        for (var i in this.vocabularies) {
          if (this.vocabularies[i].name === entry.directoryName) {
            schema = this.vocabularies[i].schema;
            break;
          }
        }
        if (!schema || schema.length === 0) {
          return 'vocabulary';
        }
        return schema;
      },

      _getParentDirectoryFor: function(entry) {
        var parent = '';
        for (var i in this.vocabularies) {
          if (this.vocabularies[i].name === entry.directoryName) {
            parent = this.vocabularies[i].parent;
            break;
          }
        }
        return parent;
      },

      _entryActions: function(o) {
        return o  === 'actions';
      },

      _refresh: function() {
        if (this.selectedVocabulary && this.selectedVocabulary.length > 0) {
          this.$.directory.path = '/directory/' + this.selectedVocabulary;
          this.entries = [];
          this.colDef = [];
          this.$.directory.get().then(function(resp) {
            var tmp = [];
            if (resp.entries.length > 0) {
              tmp = Object.keys(resp.entries[0].properties).map(function(key) {
                return {key: key, name: 'vocabularyManagement.edit.' + key, pos: this._computeColPos(key)};
              }.bind(this));
            }
            tmp.push({key: 'actions', name: 'vocabularyManagement.edit.actions', pos: 1000, actions: true});
            tmp.sort(function(a, b) {
              return a.pos - b.pos;
            });
            this.colDef = tmp;
            this.entries = resp.entries;
          }.bind(this));
        }
      },

      _displayTable: function() {
        return this.selectedVocabulary && this.selectedVocabulary.length > 0;
      },

      _value: function(entry, prop) {
        if (entry && entry.properties && prop) {
          if (prop === 'obsolete') {
            return entry.properties[prop] > 0 ? this.i18n('label.yes') : this.i18n('label.no');
          }
          return entry.properties[prop];
        } else {
          console.error('Could not resolve property ' + prop);
          return 'N/A';
        }
      },

      _computeColPos: function(key) {
        if (key === 'parent') {
          return 1;
        } else if (key === 'id') {
          return 2;
        } else if (key === 'obsolete') {
          return 98;
        } else if (key === 'ordering') {
          return 99;
        } else {
          return 50;
        }
      },

      _deleteEntry: function(e) {
        if (confirm(this.i18n('vocabularyManagement.confirmDelete'))) {
          var item = e.model.dataHost.parentNode.item;
          this.$.directory.path = '/directory/' + item.directoryName + '/' + item.properties.id;
          this.$.directory.remove().then(function() {
            this._refresh();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyDeleted')});
          }.bind(this), function(err) {
            if (err.status === 401) {
              this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                            this.i18n('vocabularyManagement.cannotDelete.referencedEntry')});
            } else {
              this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                            this.i18n('vocabularyManagement.cannotDelete.error')});
            }
          }.bind(this));
        }
      },

      _editEntry: function(e) {
        this._new = false;
        this._selectedEntry = e.model.dataHost.parentNode.item;
        this.$.dialog.toggle();
      },

      _cancel: function() {
        //this._refresh();
      },

      _save: function() {

        this.$.directory.data = this._selectedEntry;
        if (this._new) {
          this.$.directory.path = '/directory/' + this._selectedEntry.directoryName;
          this.$.directory.post().then(function() {
            this.$.dialog.toggle();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyCreated')});
            this._refresh();
          }.bind(this),
          function(err) {
            this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                          (err.message && err.message.length > 0 ? err.message :
                                           this.i18n('vocabularyManagement.cannotCreate'))});
          }.bind(this));
        } else {
          this.$.directory.path = '/directory/' + this._selectedEntry.directoryName +
            '/' + this._selectedEntry.properties.id;
          this.$.directory.put().then(function() {
            this.$.dialog.toggle();
            this.fire('notify', {message: this.i18n('vocabularyManagement.successfullyEdited')});
            this._refresh();
          }.bind(this),
          function(err) {
            this.fire('notify', {message: this.i18n('label.error').toUpperCase() + ': ' +
                                          (err.message && err.message.length > 0 ? err.message :
                                           this.i18n('vocabularyManagement.cannotEdit'))});
          }.bind(this));
        }
      },

      _isVocabularySelected: function() {
        return this.selectedVocabulary && this.selectedVocabulary.length > 0;
      },

      _createEntry: function() {
        var emptyEntry = JSON.parse(JSON.stringify(this.entries[0]));
        for (var property in this.entries[0].properties) {
          if (this.entries[0].properties.hasOwnProperty(property)) {
            emptyEntry.properties[property] = undefined;
          }
        }
        this._new = true;
        this._selectedEntry = emptyEntry;
        this.$.dialog.toggle();
      }

    });
  </script>
</dom-module>
